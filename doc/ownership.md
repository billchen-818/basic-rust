# 所有权

rust中所有权的基本原则：

- 1、一个值智能被一个变量所拥有，该变量将成为资源的所有者；
- 2、一个值同一时刻智能有一个所有者。所以不能由两个变量拥有相同的值，所以对于变量赋值、参数传递、函数返回等行为，旧的所有者会把值的所有权转移给新的所有者，以保证单一所有者的约束；
- 3、当所有者离开作用域，其拥有的值被丢弃；

```rust
#[derive(Debug)]
struct Foo(u32);

fn main() {
    let foo = Foo(42);
    let bar = foo; // foo将所有权转移给了bar，foo不再有效
    //println!("{:?}", foo); // 这里使用foo将会报错
    println!("{:?}", bar);
}
```

### Move语义

上面的第二条就是所有权的Move语义。

Rust最大的优势就是所有权规则，让堆上的数据的多重引用不在存在。

对于所有权转移之后，怎么避免不能在访问之前的变量呢？rust提供了2中方案：

- 1、Copy语义，类型实现Copy语义，在赋值或者传参时，值会字段按位拷贝（浅拷贝）
- 2、如果不希望所有权被转移，又无法使用Copy语义，可以使用`引用`或者叫`借用`

### Copy语义

一个类型实现了Copy语义，在赋值或者传参时，值会字段按位拷贝。

哪些类型实现了Copy：

- 原生类型，包括函数、不可变引用和裸指针实现了Copy
- 数组、元组，如果其内部数据结构实现了Copy，那么它们也实现了Copy
- 可变引用没有实现Copy
- 非固定大小的数据结构，没有实现Copy

> Copy trait依赖于Clone trait。

## 借用

进行借用时不会获取值的所有权，而是根据需要提供数据，通过借用，获得值的引用。使用`&`运算符放在变量之前。

rust提供两种类型的借用：`不可变借用`和`可变借用`。

不可变借用：在变量前面使用`&`运算符，就会创建一个不可变借用。

可变借用：使用`&mut`运算符在变量前面，就会创建一个可变借用。通过可变借用可以改变值。可变借用需要原有的变量自身使用关键字mut进行修饰声明。

借用规则：

- 一个引用的生命周期可能不会超过其被引用的时间。这是显而易见的，因为如果它的生命周期超过其被借用的时间，那么它将指向一个垃圾值；
- 如果存在一个值的可变借用，那么不允许其它引用（可变借用或不可变借用）在该作用域下指向相同的值。可变借用是一种独占性借用。
- 如果不存在指向某些东西的可变借用，那么在该作用域下允许出现对同一值的任意数量的不可变借用。 

## 生命周期

rust中的生命周期在引用时注解的。生命周期定义了引用相对值的原始所有者的生存周期，以及引用作用域的范围。

大多数情况下，它是隐式的，编译器通过分析代码来确定变量的生命周期。但是在某些情况下，编译器不能确定变量的生命周期，这时需要用户（程序员）来手动处理。

生命周期能够确保引用的存续时间不会超过它指向的值。生命周期是编译器使用和推断引用的有效性时会用到。

```rust
struct SomeRef<'a, T> {
    part: &'a T
}

fn main() {
    let _a = SomeRef { part: &43 };
}
```

生命周期使用`'`前缀，一般后面跟a、b、c等。

```rust
let _a： &'static str = "i love cyy";
```

`&'static`修饰的生命周期意味着这个引用在程序运行期间都是有效的。

